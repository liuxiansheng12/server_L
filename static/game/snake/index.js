/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/AI.js":
/*!*******************!*\
  !*** ./src/AI.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createSnake__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createSnake */ \"./src/createSnake.js\");\n\r\n\r\n\r\nlet os = null;\r\n\r\n\r\n\r\nfunction createAI(num) {\r\n    for(let i = 0; i < num; i ++) {\r\n        // 创建AI蛇\r\n        setTimeout(() => {\r\n            const AI = new _createSnake__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"AI蛇\");\r\n            AI.openTerval();\r\n        }, 5000 * (i + 1))\r\n    }\r\n}\r\n\r\n// 传入蛇头的位置\r\nfunction createAIRoute(osAgg, x, y, direction) {\r\n    os = osAgg;\r\n    // 找到距离最近的一个食物的坐标\r\n    const {_x, _y} = minFoodZ(x, y);\r\n    const root = new Node(x, y);\r\n\r\n    // 开始规划路径\r\n    guiHua(x, y, _x, _y, direction, root);\r\n    // 分析路径树，找到拐点\r\n    const a = guai(root, direction);\r\n\r\n    console.log(x, y);\r\n\r\n    return a;\r\n}\r\n// 得到最近食物的坐标\r\nfunction minFoodZ(x, y) {\r\n    let length = 1000;\r\n    let _x = 0;\r\n    let _y = 0;\r\n    for(let i = 0; i < os.length; i ++) {\r\n        for(let j = 0; j < os[i].length; j ++) {\r\n            if(os[i][j] && os[i][j].type == \"食物\" && \r\n                Math.abs(j - x) + Math.abs(i - y) < length) {\r\n                length = Math.abs(j - x) + Math.abs(i - y);\r\n                _x = j;\r\n                _y = i;\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        _x,\r\n        _y\r\n    }\r\n}\r\n\r\n\r\n// 规划路径，创建一个路径树\r\nfunction guiHua(x, y, _x, _y, direction, node) {\r\n    if(x === _x && y === _y) {\r\n        node[direction] = new Node(x, y);\r\n        return;\r\n    }\r\n    \r\n    \r\n    // if(zhang(x, y)) return false;\r\n    // if(arr.indexOf(`${x}-${y}`) > -1) return false;\r\n\r\n    // arr.push(`${x}-${y}`);\r\n\r\n    // console.log(x, y);\r\n\r\n    \r\n    let leftNode = new Node(x - 1, y);\r\n    let rightNode = new Node(x + 1, y);\r\n    let topNode = new Node(x, y - 1);\r\n    let bottomNode = new Node(x, y + 1);\r\n\r\n\r\n\r\n    // let left = guiHua(x - 1, y, _x, _y, \"left\", leftNode, arr);\r\n    // let right = guiHua(x + 1, y, _x, _y, \"right\", rightNode, arr);\r\n    // let top = guiHua(x, y - 1, _x, _y, \"top\", topNode, arr);\r\n    // let bottom = guiHua(x, y + 1, _x, _y, \"bottom\", bottomNode, arr);\r\n    \r\n\r\n    // if(left) node.left = leftNode;\r\n    // else if(right) node.right = rightNode;\r\n    // else if(top) node.top = topNode;\r\n    // else if(bottom) node.bottom = bottomNode;\r\n\r\n    // return left || right || top || bottom;\r\n\r\n\r\n    \r\n    if(direction == \"top\") {\r\n        if( !zhang(x, y - 1) && _y < y ) {\r\n            topMove(node, x, y, _x, _y, \"top\", topNode);\r\n        }\r\n        else {\r\n            if(_x > x && !zhang(x + 1, y)) {\r\n                rightMove(node, x, y, _x, _y, \"right\", rightNode);\r\n            }\r\n            else if(_x < x && !zhang(x - 1, y)) {\r\n                leftMove(node, x, y, _x, _y, \"left\", leftNode);\r\n            }\r\n            \r\n            else if(_y === y) {\r\n                if(_x > x && zhang(x + 1, y)) {\r\n                    // 上面无法确定方向\r\n                    const shang = shangLR(x, y, \"right\");\r\n                    // 下面有出口，即为拐点\r\n                    if(shang != null) {\r\n                        const n = new Node(x, shang);\r\n                        node.top = n;\r\n                        rightMove(n, x, shang, _x, _y, \"right\", new Node(x + 1, shang));\r\n                        return;\r\n                    }\r\n                }\r\n                else if(_x < x && zhang(x, y)) {\r\n                    // 上面无法确定方向\r\n                    const shang = shangLR(x, y, \"left\");\r\n                    // 下面有出口，即为拐点\r\n                    if(shang != null) {\r\n                        const n = new Node(x, shang);\r\n                        node.top = n;\r\n                        leftMove(n, x, shang, _x, _y, \"left\", new Node(x - 1, shang));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            else {\r\n                // 判断下半段有没有出口(食物与蛇在同一条横线上，但是前方有障碍物)\r\n                // 上面无法确定方向\r\n                const you = youLR(x, y, \"top\");\r\n                // 下面有出口，即为拐点\r\n                if(you != null) {\r\n                    const n = new Node(you, y);\r\n                    node.right = n;\r\n                    topMove(n, you, y, _x, _y, \"top\", new Node(you, y - 1) );\r\n                    return;\r\n                }\r\n                // 下面没有出口，判断上面有没有出口\r\n                const zuo = zuoLR(x, y, \"top\");\r\n                // 上面有出口，即为拐点\r\n                if(zuo != null) {\r\n                    const n = new Node(zuo, y);\r\n                    node.left = n;\r\n                    topMove(n, zuo, y, _x, _y, \"top\", new Node(zuo, y - 1) );\r\n                    return;\r\n                }\r\n                // 上下都没有出口，\r\n            }\r\n        }\r\n    }\r\n    else if(direction == \"bottom\") {\r\n        if( !zhang(x, y + 1)  && _y > y ) {\r\n            bottomMove(node, x, y, _x, _y, \"bottom\", bottomNode);\r\n        }\r\n        else {\r\n            if(_x > x && !zhang(x + 1, y)) {\r\n                rightMove(node, x, y, _x, _y, \"right\", rightNode);\r\n            }\r\n            else if(_x < x && !zhang(x - 1, y)) {\r\n                leftMove(node, x, y, _x, _y, \"left\", leftNode);\r\n            }\r\n            \r\n            else if(_y === y) {\r\n                if(_x > x && zhang(x + 1, y)) {\r\n                    // 上面无法确定方向\r\n                    const xia = xiaLR(x, y, \"right\");\r\n                    // 下面有出口，即为拐点\r\n                    if(xia != null) {\r\n                        const n = new Node(x, xia);\r\n                        node.bottom = n;\r\n                        rightMove(n, x, xia, _x, _y, \"right\", new Node(x + 1, xia));\r\n                        return;\r\n                    }\r\n                }\r\n                else if(_x < x && zhang(x - 1, y)) {\r\n                    // 上面无法确定方向\r\n                    const xia = xiaLR(x, y, \"left\");\r\n                    // 下面有出口，即为拐点\r\n                    if(xia != null) {\r\n                        const n = new Node(x, xia);\r\n                        node.bottom = n;\r\n                        leftMove(n, x, xia, _x, _y, \"left\", new Node(x - 1, xia));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            else {\r\n                // 判断下半段有没有出口(食物与蛇在同一条横线上，但是前方有障碍物)\r\n                // 上面无法确定方向\r\n                const you = youLR(x, y, \"bottom\");\r\n                // 下面有出口，即为拐点\r\n                if(you != null) {\r\n                    const n = new Node(you, y);\r\n                    node.right = n;\r\n                    bottomMove(n, you, y, _x, _y, \"bottom\", new Node(you, y + 1) );\r\n                    return;\r\n                }\r\n                // 下面没有出口，判断上面有没有出口\r\n                const zuo = zuoLR(x, y, \"bottom\");\r\n\r\n                // 上面有出口，即为拐点\r\n                if(zuo != null) {\r\n                    const n = new Node(zuo, y);\r\n                    node.left = n;\r\n                    bottomMove(n, zuo, y, _x, _y, \"bottom\", new Node(zuo, y + 1) );\r\n                    return;\r\n                }\r\n                // 上下都没有出口，\r\n            }\r\n        }\r\n    }\r\n    else if(direction == \"left\") {\r\n        if( !zhang(x - 1, y) && _x < x ) {\r\n            leftMove(node, x, y, _x, _y, \"left\", leftNode);\r\n        }\r\n        else {\r\n            if(_y > y && !zhang(x, y + 1)) {\r\n                bottomMove(node, x, y, _x, _y, \"bottom\", bottomNode);\r\n            }\r\n            else if(_y < y && !zhang(x, y - 1)) {\r\n                topMove(node, x, y, _x, _y, \"top\", topNode);\r\n            }\r\n\r\n            else if(_x === x) {\r\n                if(_y > y && zhang(x, y + 1)) {\r\n                    // 上面无法确定方向\r\n                    const zuo = zuoLR(x, y, \"bottom\");\r\n                    // 下面有出口，即为拐点\r\n                    if(zuo != null) {\r\n                        const n = new Node(zuo, y);\r\n                        node.left = n;\r\n                        bottomMove(n, zuo, y, _x, _y, \"bottom\", new Node(zuo, y + 1));\r\n                        return;\r\n                    }\r\n                }\r\n                else if(_y < y && zhang(x, y - 1)) {\r\n                    // 上面无法确定方向\r\n                    const zuo = zuoLR(x, y, \"top\");\r\n                    // 下面有出口，即为拐点\r\n                    if(zuo != null) {\r\n                        const n = new Node(zuo, y);\r\n                        node.left = n;\r\n                        topMove(n, zuo, y, _x, _y, \"top\", new Node(zuo, y - 1));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            else {\r\n                // 判断下半段有没有出口(食物与蛇在同一条横线上，但是前方有障碍物)\r\n                // 上面无法确定方向\r\n                const xia = xiaLR(x, y, \"left\");\r\n                // 下面有出口，即为拐点\r\n                if(xia != null) {\r\n                    const n = new Node(x, xia);\r\n                    node.bottom = n;\r\n                    leftMove(n, x, xia, _x, _y, \"left\", new Node(x - 1, xia) );\r\n                    return;\r\n                }\r\n                // 下面没有出口，判断上面有没有出口\r\n                const shang = shangLR(x, y, \"left\");\r\n                // 上面有出口，即为拐点\r\n                if(shang != null) {\r\n                    const n = new Node(x, shang);\r\n                    node.top = n;\r\n                    leftMove(n, x, shang, _x, _y, \"left\", new Node(x - 1, shang) );\r\n                    return;\r\n                }\r\n                // 上下都没有出口，\r\n            }\r\n        }\r\n    }\r\n    else if(direction == \"right\") {\r\n        if( !zhang(x + 1, y) && _x > x ) {\r\n            rightMove(node, x, y, _x, _y, \"right\", rightNode);\r\n        }\r\n        else {\r\n            if(_y > y && !zhang(x, y + 1)) {\r\n                bottomMove(node, x, y, _x, _y, \"bottom\", bottomNode);\r\n            }\r\n            else if(_y < y && !zhang(x, y - 1)) {\r\n                topMove(node, x, y, _x, _y, \"top\", topNode);\r\n            }\r\n\r\n            else if(_x === x) {\r\n                if(_y > y && zhang(x, y + 1)) {\r\n                    // 上面无法确定方向\r\n                    const you = youLR(x, y, \"bottom\");\r\n                    // 下面有出口，即为拐点\r\n                    if(you != null) {\r\n                        const n = new Node(you, y);\r\n                        node.right = n;\r\n                        bottomMove(n, you, y, _x, _y, \"bottom\", new Node(you, y + 1));\r\n                        return;\r\n                    }\r\n                }\r\n                else if(_y < y && zhang(x, y - 1)) {\r\n                    // 上面无法确定方向\r\n                    const you = youLR(x, y, \"top\");\r\n                    // 下面有出口，即为拐点\r\n                    if(you != null) {\r\n                        const n = new Node(you, y);\r\n                        node.right = n;\r\n                        topMove(n, you, y, _x, _y, \"top\", new Node(you, y - 1));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            else {\r\n                // 判断下半段有没有出口(食物与蛇在同一条横线上，但是前方有障碍物)\r\n                // 上面无法确定方向\r\n                const xia = xiaLR(x, y, \"right\");\r\n                // 下面有出口，即为拐点\r\n                if(xia != null) {\r\n                    const n = new Node(x, xia);\r\n                    node.bottom = n;\r\n                    rightMove(n, x, xia, _x, _y, \"right\", new Node(x + 1, xia) );\r\n                    return;\r\n                }\r\n                // 下面没有出口，判断上面有没有出口\r\n                const shang = shangLR(x, y, \"right\");\r\n                // 上面有出口，即为拐点\r\n                if(shang != null) {\r\n                    const n = new Node(x, shang);\r\n                    node.top = n;\r\n                    rightMove(n, x, shang, _x, _y, \"right\", new Node(x + 1, shang) );\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction Node(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.left = null;\r\n    this.right = null;\r\n    this.top = null;\r\n    this.bottom = null;\r\n}\r\nfunction leftMove(node, x, y, _x, _y, direction, topNode) {\r\n    node.left = topNode;\r\n    guiHua(x - 1, y, _x, _y, direction, topNode);\r\n}\r\nfunction rightMove(node, x, y, _x, _y, direction, topNode) {\r\n    node.right = topNode;\r\n    guiHua(x + 1, y, _x, _y, direction, topNode);\r\n}\r\nfunction topMove(node, x, y, _x, _y, direction, topNode) {\r\n    node.top = topNode;\r\n    guiHua(x, y - 1, _x, _y, direction, topNode);\r\n}\r\nfunction bottomMove(node, x, y, _x, _y, direction, topNode) {\r\n    node.bottom = topNode;\r\n    guiHua(x, y + 1, _x, _y, direction, topNode);\r\n}\r\n\r\n// 横向扫下半段，得到往左或者往右的出口\r\nfunction xiaLR(x, y, direction) {\r\n    for( let i = y + 1; i < os.length; i ++) {\r\n        if(zhang(x, i)) return null;\r\n        if(direction === \"right\" && !zhang(x + 1, i)) return i;\r\n        if(direction === \"left\" && !zhang(x - 1, i)) return i;\r\n    }\r\n    return null;\r\n}\r\nfunction shangLR(x, y, direction) {\r\n    for( let i = y - 1; i >= 0; i --) {\r\n        if(zhang(x, i)) return null;\r\n        if(direction === \"right\" && !zhang(x + 1, i)) return i;\r\n        if(direction === \"left\" && !zhang(x - 1, i)) return i;\r\n    }\r\n    return null;\r\n}\r\nfunction zuoLR(x, y, direction) {\r\n    for( let i = x - 1; i >= 0; i --) {\r\n        if(zhang(i, y)) return null;\r\n        if(direction === \"top\" && !zhang(i, y - 1)) return i;\r\n        if(direction === \"bottom\" && !zhang(i, y + 1)) return i;\r\n    }\r\n    return null;\r\n}\r\nfunction youLR(x, y, direction) {\r\n    for( let i = x + 1; i < os[y].length; i ++) {\r\n        if(zhang(i, y)) return null;\r\n        if(direction === \"top\" && !zhang(i, y - 1)) return i;\r\n        if(direction === \"bottom\" && !zhang(i, y + 1)) return i;\r\n    }\r\n    return null;\r\n}\r\n\r\n// 分析路径树，找到拐点\r\nfunction guai(root, direction, arr = []) {\r\n    if(root == null) return arr;\r\n    // 顺着该方向是否可以走通\r\n    if(root[direction]) {\r\n        guai(root[direction], direction, arr)\r\n    }\r\n    // 走不通，产生了拐点\r\n    else {\r\n        const f = fang(root);\r\n        if(!f) return;\r\n        // 保存拐点信息\r\n        arr.push({\r\n            x: root.x,\r\n            y: root.y,\r\n            direction: f\r\n        });\r\n        guai(root[f], f, arr);\r\n    }\r\n    return arr;\r\n}\r\n\r\n// 判断某个位置是否有障碍物\r\nfunction zhang(x, y) {\r\n    if(x < 0 || y < 0 || x >= os[y].length || y >= os.length) return true;   \r\n    if(os[y][x] && (os[y][x].type === \"墙\" || os[y][x].type === \"蛇\")) return true;\r\n    return false;\r\n}\r\n// 根据节点，得到新的方向\r\nfunction fang(root) {\r\n    if(root.left) return \"left\";\r\n    else if(root.right) return \"right\";\r\n    else if(root.top) return \"top\";\r\n    else if(root.bottom) return \"bottom\";\r\n    else return false;\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    createAI,\r\n    createAIRoute\r\n});\n\n//# sourceURL=webpack:///./src/AI.js?");

/***/ }),

/***/ "./src/createFood.js":
/*!***************************!*\
  !*** ./src/createFood.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst app = document.querySelector(\"#snake\");\r\n\r\nlet os = null;\r\n\r\nclass Food {\r\n    constructor(osData) {\r\n        osData && (os = osData);\r\n\r\n        this.width = 10;\r\n        this.height = 10;\r\n        \r\n        // 食物的渲染\r\n        this.createDom();\r\n        \r\n        // 随机产生一个食物的位置\r\n        this.rp();\r\n    }\r\n    // 随机产生食物的位置\r\n    rp() {\r\n        const x = parseInt(Math.random() * 60);\r\n        const y = parseInt(Math.random() * 60);\r\n        // 判断食物位置有没有东西，如果有，在重新生成，没有的话，保存\r\n        if( os[y][x] || x <= 3 ) this.rp();\r\n        else {\r\n            this.left = x * 10;\r\n            this.top = y * 10;\r\n            this.dom.style.left = this.left + \"px\";\r\n            this.dom.style.top = this.top + \"px\";\r\n            os[y][x] = {\r\n                type: \"食物\",\r\n                dom: this.dom,\r\n                a: true\r\n            }\r\n        }\r\n    }\r\n    // 食物的渲染\r\n    createDom() {\r\n        const dom = document.createElement(\"div\");\r\n        dom.style.width = this.width + \"px\";\r\n        dom.style.height = this.height + \"px\";\r\n        dom.style.position = \"absolute\";\r\n        dom.style.boxSizing = \"border-box\";\r\n        dom.style.border = \"1px solid #fff\";\r\n        \r\n        dom.style.background = \"#FF9800\";\r\n        \r\n        app.appendChild(dom);\r\n        this.dom = dom;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Food);\n\n//# sourceURL=webpack:///./src/createFood.js?");

/***/ }),

/***/ "./src/createSnake.js":
/*!****************************!*\
  !*** ./src/createSnake.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createFood__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createFood */ \"./src/createFood.js\");\n/* harmony import */ var _AI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AI */ \"./src/AI.js\");\n\r\n\r\n\r\n\r\nconst app = document.querySelector(\"#snake\");\r\nconst menu = document.querySelector(\".menu\");\r\n\r\n// 全局背景对象\r\nlet os = null;\r\n// 保存人工蛇是否死亡的标识\r\nlet dS = false;\r\n\r\nclass Snake{\r\n    constructor(name, osData) {\r\n        // 保存全局背景对象\r\n        osData && (os = osData);\r\n\r\n        this.name = name;\r\n        this.length = 5;\r\n        this.moveLength = 5;\r\n        this.direction = \"right\";\r\n        // 影响蛇移动的速度\r\n        this.time = 250;\r\n        this.distance = 10;\r\n        this.snokeBody = [];\r\n        this.terval = null;\r\n        // AI蛇走几步，智能改变方向\r\n        this.AILingth = 0;\r\n        this.dS = false;\r\n\r\n        this.AIroute = [];\r\n        this.AIJin = false;\r\n\r\n        // 构建初始化蛇\r\n        this.createSnake();\r\n        // 表示创建的是人工蛇\r\n        if(name !== \"AI蛇\") dS = false;\r\n    }\r\n\r\n    // 构建蛇\r\n    createSnake() {\r\n        for(let i = 0; i < this.length; i ++) {\r\n            const type = i === this.length - 1 ? \"蛇头\" : \"蛇身\";\r\n            // 保存蛇身对象\r\n            this.snokeBody[i] = new SnakeBody(this.name, type, 10, 10, this.direction, this.distance, this);\r\n        }\r\n    }\r\n\r\n    // 开启蛇移动定时器的方法\r\n    openTerval() {\r\n        // 规划初始的路径\r\n        if(this.name === \"AI蛇\") {\r\n            // this.uRC(this.length, 1, \"right\");\r\n            this.AIroute = _AI__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createAIRoute(os, this.length, 1, \"right\");\r\n        }\r\n\r\n        this.terval = setInterval( () => {\r\n            // 判断人工蛇是否死亡，如果死亡，关闭智能蛇的定时器\r\n            if(dS) {\r\n                this.death();\r\n                return;\r\n            }\r\n            // 蛇进行移动，需要移动的方法\r\n            this.move();\r\n        }, this.time )\r\n    }\r\n    // 蛇移动的方法\r\n    move() {\r\n        this.AI && this.AI();\r\n        let boo = null;\r\n\r\n        // 初始时，滑动弹出\r\n        if(this.moveLength >= 0) {\r\n            this.moveLength --;\r\n        }\r\n        for(let i = this.snokeBody.length - 1; i >= 0; i --) {\r\n            if(i < this.moveLength) return;\r\n\r\n            // 蛇身动一下\r\n            const b = this.snokeBody[i].move();\r\n            // 蛇死亡的处理\r\n            if(b === \"死亡\") {\r\n                boo = b; \r\n            }\r\n            // 蛇吃食的处理(此时蛇尾还没有进行运动，可以在最后拼接一节)\r\n            else if(b === \"食物\") {\r\n                boo = b; \r\n            }\r\n        }\r\n        // 蛇死亡的处理\r\n        if(boo === \"死亡\") {\r\n            this.death();\r\n        }\r\n        // 蛇吃食的处理(此时蛇尾还没有进行运动，可以在最后拼接一节)\r\n        else if(boo === \"食物\") {\r\n            // 蛇的长度加一\r\n            this.length += 1;\r\n            // 吃食的处理\r\n            this.eatFood();\r\n        }\r\n    }\r\n    // 绑定事件，蛇拐弯\r\n    bEvent() {\r\n        window.onkeydown = (e) => {\r\n            // 得到新的方向\r\n            const direction = this.comDirection(e.keyCode);\r\n            // 方向发生变化，蛇拐弯，保存拐点，蛇头的位置就是拐点\r\n            this.cD(direction);\r\n        }\r\n    }\r\n    // 改变方向\r\n    cD(direction) {\r\n        if(direction !== this.direction) {\r\n            this.direction = direction;\r\n            // 取拐点\r\n            const turn = {};\r\n            turn.left = this.snokeBody[ this.snokeBody.length - 1 ].left;\r\n            turn.top = this.snokeBody[ this.snokeBody.length - 1 ].top;\r\n            turn.direction = direction;\r\n            // 设置蛇身的拐点\r\n            this.setSBTurn(turn);\r\n        }\r\n    }\r\n    // 根据按键，计算出方向\r\n    comDirection(keyCode) {\r\n        if( this.direction === \"left\" || this.direction === \"right\" ) {\r\n            if(keyCode == 38) return \"top\";\r\n            else if(keyCode == 40) return \"bottom\";\r\n        }\r\n        else if( this.direction === \"top\" || this.direction === \"bottom\" ) {\r\n            if(keyCode == 37) return \"left\";\r\n            else if(keyCode == 39) return \"right\";\r\n        }\r\n        // 还是返回之前的方向，没有改变\r\n        return this.direction;\r\n    }\r\n    // 设置蛇身的拐点\r\n    setSBTurn(turn) {\r\n        // 每个蛇身对象，都需要设置\r\n        this.snokeBody.forEach( (item, i) => {\r\n            item.turn.push(turn);\r\n        } )\r\n    }\r\n    // 蛇死亡的处理\r\n    death() {\r\n        console.log(\"蛇死亡\");\r\n        // 关掉定时器\r\n        clearInterval( this.terval );\r\n        // 标记当前蛇已经死亡\r\n        this.dS = true;\r\n\r\n        // 如果是智能蛇死亡，不清空背景，人工蛇还在运动\r\n        if(this.name !== \"AI蛇\") {\r\n            // 关掉事件函数\r\n            window.onkeydown = null;\r\n            dS = true;\r\n            menu.style.display = \"block\";\r\n            app.innerHTML = \"\";\r\n            for(let i = 0; i < os.length; i ++) {\r\n                for(let j = 0; j < os[i].length; j ++) {\r\n                    if(os[i][j] && os[i][j].type !== \"墙\") os[i][j] = null;\r\n                }\r\n            }\r\n            os = null;\r\n            alert(\"蛇死亡\");\r\n        }\r\n        // 如果是智能蛇\r\n        else {\r\n            if(dS) return;\r\n            // 智能蛇的蛇体变成实物\r\n            const food = this.snokeBody;\r\n            for(let i = 0; i < food.length; i ++) {\r\n                const x = food[i].left / 10;\r\n                const y = food[i].top / 10;\r\n                const dom = food[i].dom;\r\n                dom.style.background = \"#FF9800\";\r\n                if( (!os[y][x] || (os[y][x] && os[y][x].r == this)) && (y > 1 || x > 6)) {\r\n                    os[y][x] = {\r\n                        dom,\r\n                        type: \"食物\"\r\n                    }\r\n                }else {\r\n                    dom.remove();\r\n                }\r\n            }\r\n            // 在创建一条智能蛇\r\n            const AI = new Snake(\"AI蛇\");\r\n            AI.openTerval();\r\n        }\r\n    }\r\n    // 吃食的处理\r\n    eatFood() {\r\n        // 取出蛇尾的位置\r\n        let x = this.snokeBody[0].left / 10;\r\n        let y = this.snokeBody[0].top / 10;\r\n        const turn = [ ...this.snokeBody[0].turn ];\r\n        // 蛇尾移动的方向\r\n        const direction = this.snokeBody[0].direction;\r\n        if(direction == \"top\") y += 1;\r\n        else if(direction == \"bottom\") y -= 1;\r\n        else if(direction == \"left\") x += 1;\r\n        else if(direction == \"right\") x -= 1;\r\n\r\n        // 构建出一截蛇身数据\r\n        const snakeBody = new SnakeBody(this.name, \"蛇身\", x * 10, y * 10, direction, this.distance, this);\r\n        // 保存拐点信息\r\n        snakeBody.turn = turn;\r\n        this.snokeBody.unshift(snakeBody);\r\n        // 标识不用手动修改，会被蛇身直接替换掉，也可以修改\r\n        \r\n        /******************************************************************* */\r\n        if(this.name === \"AI蛇\") {\r\n            // 获取蛇头移动的方向\r\n            const direction = this.snokeBody[ this.snokeBody.length - 1 ].direction;\r\n            // 获取蛇头的位置\r\n            let x = this.snokeBody[ this.snokeBody.length - 1 ].left / 10;\r\n            let y = this.snokeBody[ this.snokeBody.length - 1 ].top / 10;\r\n            \r\n\r\n            // 规划路径\r\n            this.AIroute = _AI__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createAIRoute(os, x, y, direction);\r\n            this.fang(x, y, direction);\r\n        }\r\n    }\r\n\r\n\r\n    // 智能蛇的自动拐弯\r\n    AI() {\r\n        // 蛇头已经弹出，拐点的步数才开始递减\r\n        if( this.moveLength > 0 ) return;\r\n        \r\n        if(this.name !== \"AI蛇\") return;\r\n\r\n        // 此时蛇还没有移动\r\n        // 获取蛇头移动的方向\r\n        const direction = this.snokeBody[ this.snokeBody.length - 1 ].direction;\r\n        // 获取蛇头的位置\r\n        let x = this.snokeBody[ this.snokeBody.length - 1 ].left / 10;\r\n        let y = this.snokeBody[ this.snokeBody.length - 1 ].top / 10;\r\n\r\n\r\n        // 之前触发的是紧急拐弯\r\n        if(this.AIJin) {\r\n            this.AIroute = _AI__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createAIRoute(os, x, y, direction);\r\n            this.AIJin = false;\r\n        }\r\n\r\n        const AIg = this.fang(x, y, direction);\r\n        \r\n        if(AIg !== direction) this.cD(AIg);\r\n    }\r\n    fang(x, y, direction) {\r\n        // 获取到当前点，是不是拐点\r\n        let AIg = this.guai(x, y, direction);\r\n        \r\n        // 前方有障碍物，重新规划路径\r\n        if( this.AItL(direction, x, y) || this.AItou(direction, x, y) ) {\r\n            // 判断路径中是否在该位置进行了躲避\r\n            if(direction == \"top\" || direction == \"bottom\") {\r\n                if(AIg != \"left\" && AIg != \"right\") {\r\n                    this.AIroute = _AI__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createAIRoute(os, x, y, direction);\r\n                    AIg = this.guai(x, y, direction);\r\n                    if(AIg === \"top\" || AIg == \"bottom\") {\r\n                        // 紧急拐弯\r\n                        if( this.AItL(\"right\", x, y) ) AIg = \"right\";\r\n                        else if( this.AItL(\"left\", x, y) ) AIg = \"left\";\r\n                        this.AIJin = true;\r\n                    }\r\n                }\r\n            }\r\n            else if(direction == \"left\" || direction == \"right\") {\r\n                if(AIg != \"top\" && AIg != \"bottom\") {\r\n                    this.AIroute = _AI__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createAIRoute(os, x, y, direction);\r\n                    AIg = this.guai(x, y, direction);\r\n                    if(AIg === \"left\" || AIg == \"right\") {\r\n                        // 紧急拐弯\r\n                        if( this.AItL(\"top\", x, y) ) AIg = \"top\";\r\n                        else if( this.AItL(\"bottom\", x, y) ) AIg = \"bottom\";\r\n                        this.AIJin = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return AIg;  \r\n    }\r\n    guai(x, y, direction) {\r\n        if(!this.AIroute) return direction;\r\n        for(let i = 0; i < this.AIroute.length; i ++) {\r\n            if( this.AIroute[i].x === x &&  this.AIroute[i].y === y ) {\r\n                return this.AIroute[i].direction;\r\n            }\r\n        }\r\n        return direction;\r\n    }\r\n    // 返回将要前往的位置\r\n    jiang(direction, x, y) {\r\n        let _x = x;\r\n        let _y = y;\r\n        \r\n        // 得到蛇头将要前往的目标位置点，判断有没有障碍物\r\n        if(direction == \"top\") _y -= 1;\r\n        else if(direction == \"bottom\") _y += 1;\r\n        else if(direction == \"left\") _x -= 1;\r\n        else if(direction == \"right\") _x += 1;\r\n\r\n        return {\r\n            _x, _y\r\n        }\r\n    }\r\n    // 判断蛇头将要前往的位置，有没有障碍物\r\n    AItL(direction, x, y) {\r\n        \r\n        let {_x, _y} = this.jiang(direction, x, y);\r\n        \r\n        if( this.AIoj(_x, _y) ) return true;\r\n    }\r\n    // 判断将要前往的位置，是否也有蛇头前往\r\n    // 如果有拐弯，否则两个同时到达该位置，就会发生碰撞\r\n    AItou(direction, x, y) {\r\n        let {_x, _y} = this.jiang(direction, x, y);\r\n        // 前方有障碍物\r\n        if( os[_y][_x] && os[_y][_x].t === \"蛇头\" ) return true;\r\n        // 有其它蛇头将要前往该位置\r\n        for(let i = _y - 1; i <= _y + 1; i ++) {\r\n            for(let j = _x - 1; j <= _x + 1; j ++) {\r\n                if( os[i][j] && os[i][j].t === \"蛇头\" && os[i][j].r !== this ) {\r\n                    if(i === _y - 1 || j === _x || os[i][j].r.direction == \"bottom\") return true;\r\n                    if(i === _y + 1 || j === _x || os[i][j].r.direction == \"top\") return true;\r\n                    if(i === _y || j === _x + 1 || os[i][j].r.direction == \"left\") return true;\r\n                    if(i === _y || j === _x - 1 || os[i][j].r.direction == \"right\") return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 判断某个位置有没有障碍物\r\n    AIoj(x, y) {\r\n        if(os[y][x] && (os[y][x].type === \"墙\" || os[y][x].type === \"蛇\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n\r\nclass SnakeBody {\r\n    constructor(name, type, left, top, direction, distance, root) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.width = 10;\r\n        this.height = 10;\r\n        this.left = left;\r\n        this.top = top;\r\n        this.direction = direction;\r\n        this.distance = distance;\r\n        this.dom = null;\r\n        this.turn = [];\r\n        this.root = root;\r\n\r\n        this.createDom();\r\n    }\r\n    createDom() {\r\n        const dom = document.createElement(\"div\");\r\n        dom.style.width = this.width + \"px\";\r\n        dom.style.height = this.height + \"px\";\r\n        dom.style.position = \"absolute\";\r\n        dom.style.boxSizing = \"border-box\";\r\n        dom.style.border = \"1px solid #fff\";\r\n        // 在背景中添加蛇身的标识\r\n        this.addObstacle();\r\n\r\n        if(this.type === \"蛇头\") {\r\n            dom.style.background = \"#E91E63\";\r\n        }\r\n        else {\r\n            if(this.name === \"AI蛇\") dom.style.background = \"#673AB7\";\r\n            else dom.style.background = \"#9c27b0\";\r\n        }\r\n        app.appendChild(dom);\r\n        this.dom = dom;\r\n\r\n        // 渲染蛇身的位置\r\n        this.rl();\r\n    }\r\n    // 在背景中添加蛇身标识，表明此处为障碍物\r\n    addObstacle() {\r\n        // 确定位置\r\n        const x = this.left / 10;\r\n        const y = this.top / 10;\r\n        if( os[y][x] && os[y][x].type === \"墙\") return;\r\n        os[y][x] = {\r\n            type: \"蛇\",\r\n            name: this.name,\r\n            t: this.type,\r\n            r: this.root\r\n        }\r\n    }\r\n    // 在背景中移除当前蛇身的处理，障碍物移除\r\n    clearObstacle() {\r\n        // 确定位置\r\n        const x = this.left / 10;\r\n        const y = this.top / 10;\r\n        if( os[y][x] && os[y][x].type === \"墙\") return;\r\n        os[y][x] = null;\r\n    }\r\n    // 根据蛇身位置，渲染蛇身\r\n    rl() {\r\n        this.dom.style.left = this.left + \"px\";\r\n        this.dom.style.top = this.top + \"px\";\r\n    }\r\n    // 蛇身移动\r\n    move() {\r\n        if(!os || this.root.dS) return;\r\n\r\n        // 在背景中移除当前蛇身的处理，障碍物移除，蛇将要前往下一个位置\r\n        this.clearObstacle();\r\n\r\n        // 查看当前位置是否为拐点，如果是，改变方向\r\n        this.changeDirection();\r\n        // 根据方向，更新下次前往的坐标\r\n        this[this.direction + \"Move\"]();\r\n        \r\n        // 进行蛇头前方障碍物的判断\r\n        if( this.oj() ) return \"死亡\";\r\n\r\n        // 根据蛇身数据，渲染蛇身的位置\r\n        this.rl();\r\n\r\n        // 判断蛇头前方是否为食物(吃食，蛇头要正常移动，所以放在移动渲染的后面退出函数)\r\n        if( this.fj() ) return \"食物\";\r\n\r\n        // 在背景中添加蛇身的标识，蛇身的新位置\r\n        this.addObstacle();\r\n        \r\n        return false;\r\n    }\r\n    // 移动方向的改变\r\n    changeDirection() {\r\n        // 存在拐点，判断是否到达拐点\r\n        if( this.turn.length > 0 ) {\r\n            for(let i = 0; i < this.turn.length; i ++) {\r\n                if(this.left === this.turn[i].left && this.top === this.turn[i].top) {\r\n                    // 拐弯\r\n                    this.direction = this.turn[i].direction;\r\n                    // 清除拐点\r\n                    this.turn.splice(i, 1);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 蛇身左移函数\r\n    leftMove() {\r\n        this.left -= this.distance;\r\n    }\r\n    // 蛇身右移函数\r\n    rightMove() {\r\n        this.left += this.distance;\r\n    }\r\n    // 蛇身上移函数\r\n    topMove() {\r\n        this.top -= this.distance;\r\n    }\r\n    // 蛇身下移函数\r\n    bottomMove() {\r\n        this.top += this.distance;\r\n    }\r\n\r\n    // 进行蛇头前方障碍物的判断\r\n    oj() {\r\n        if(this.type === \"蛇头\") {\r\n            // 判断当前蛇头位置，是否碰到了障碍物\r\n            // 确定位置\r\n            const x = this.left / 10;\r\n            const y = this.top / 10;\r\n            if(os[y][x] && (os[y][x].type === \"蛇\" || os[y][x].type === \"墙\")) {\r\n                this.root.dS = true;\r\n                if( this.direction == \"left\") this.left += 10;\r\n                else if( this.direction == \"right\") this.left -= 10;\r\n                else if( this.direction == \"bottom\") this.top -= 10;\r\n                else if( this.direction == \"top\") this.top += 10;\r\n                this.rl();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // 进行蛇头前方食物的判断\r\n    fj() {\r\n        if(this.type === \"蛇头\") {\r\n            // 判断当前蛇头位置，是否碰到了障碍物\r\n            // 确定位置\r\n            const x = this.left / 10;\r\n            const y = this.top / 10;\r\n            if(os[y][x] && os[y][x].type === \"食物\") {\r\n                os[y][x].dom.remove();\r\n                // 创建新的食物，吃的是系统生成的食物，而不是AI蛇死亡的食物\r\n                if(os[y][x].a) new _createFood__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Snake);\n\n//# sourceURL=webpack:///./src/createSnake.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\r\n\r\n\r\nconst menu = document.querySelector(\".menu\");\r\nconst sPPlus = document.querySelector(\".sPPlus\");\r\nconst sPNumDom = document.querySelector(\".sPNum\");\r\nconst sPReduce = document.querySelector(\".sPReduce\");\r\n\r\n\r\nconst enable = document.querySelector(\".enable\");\r\nconst AINumG = document.querySelector(\".AINumG\");\r\nconst AIPlus = document.querySelector(\".AIPlus\");\r\nconst AINumDom = document.querySelector(\".AINum\");\r\nconst AIReduce = document.querySelector(\".AIReduce\");\r\nconst start = document.querySelector(\".start\");\r\n\r\n\r\n\r\nsPPlus.onclick = () => {\r\n    if(sPNumDom.innerHTML < 9) sPNumDom.innerHTML = +sPNumDom.innerHTML + 1;\r\n}\r\nsPReduce.onclick = () => {\r\n    if(sPNumDom.innerHTML > 1) sPNumDom.innerHTML -= 1;\r\n}\r\n\r\n\r\nlet AIB = false;\r\n\r\nenable.onclick = () => {\r\n    AIB = !AIB;\r\n    if(AIB) {\r\n        AINumG.style.display = \"block\";\r\n        enable.innerHTML = \"关闭智能蛇\";\r\n    }\r\n    else {\r\n        AINumG.style.display = \"none\";\r\n        enable.innerHTML = \"启用智能蛇\";\r\n    }\r\n}\r\nAIPlus.onclick = () => {\r\n    if(AINumDom.innerHTML < 3) AINumDom.innerHTML = +AINumDom.innerHTML + 1;\r\n}\r\nAIReduce.onclick = () => {\r\n    if(AINumDom.innerHTML > 1) AINumDom.innerHTML -= 1;\r\n}\r\n\r\nstart.onclick = () => {\r\n    // 获取关数\r\n    const sPNum = +sPNumDom.innerHTML;\r\n    // 获取智能蛇开启的数量\r\n    const AINum = +AINumDom.innerHTML;\r\n    menu.style.display = \"none\";\r\n    \r\n    Object(_main_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(sPNum, AINum, AIB);\r\n}\r\n\r\n\r\n\r\n\r\n// main(1);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./os */ \"./src/os.js\");\n/* harmony import */ var _createSnake__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createSnake */ \"./src/createSnake.js\");\n/* harmony import */ var _AI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AI */ \"./src/AI.js\");\n/* harmony import */ var _createFood__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createFood */ \"./src/createFood.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 获取全局背景对象\r\nlet os = null;\r\n\r\nfunction main(shutNum, AInum, AIB) {\r\n    os = Object(_os__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(shutNum - 1);\r\n    // 渲染全局障碍物 \r\n    rWall(os); \r\n    // 渲染初始化蛇  \r\n    const snake = new _createSnake__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"人工蛇\", os); \r\n    // 构建初始化食物   \r\n    createNumFood()   \r\n    // 蛇移动   \r\n    snake.openTerval();  \r\n    // 绑定事件，蛇拐弯   \r\n    snake.bEvent();  \r\n    // 启动AI\r\n    AIB && _AI__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createAI(AInum);\r\n}\r\n// 构建一定数量的食物\r\nfunction createNumFood() {\r\n    for(let i = 0; i < 8; i ++) {\r\n        // 构建初始食物  \r\n        new _createFood__WEBPACK_IMPORTED_MODULE_3__[\"default\"](os);\r\n    }\r\n}\r\n\r\nconst app = document.querySelector(\"#snake\");\r\nfunction rWall(os) { \r\n    os.forEach( (item, i) => {  \r\n        item.forEach( (key, j) => {     \r\n            if(key && key.type === \"墙\") {       \r\n                const dom = document.createElement(\"div\");  \r\n                dom.style.width = \"10px\";\r\n                dom.style.height = \"10px\";   \r\n                dom.style.left = j * 10 + \"px\";\r\n                dom.style.top = i * 10 + \"px\";  \r\n                dom.style.position = \"absolute\";  \r\n                dom.style.background = \"#799456\"; \r\n                dom.style.boxSizing = \"border-box\";\r\n                dom.style.border = \"1px solid #fff\";\r\n                app.appendChild(dom);    \r\n            }\r\n        } )\r\n    } )\r\n}\r\n                        \r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/os.js":
/*!*******************!*\
  !*** ./src/os.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nconst os = [];\r\n\r\n\r\nfunction createOs() {\r\n    // 创建第一关的数据\r\n    os[0] = new Array(60);\r\n    for(let i = 0; i < os[0].length; i ++) {\r\n        os[0][i] = new Array(60);\r\n        for(let j = 0; j < os[0][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[0].length - 1 || j === os[0][i].length - 1) {\r\n                wall(i, j, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第二关\r\n    os[1] = new Array(60);\r\n    for(let i = 0; i < os[1].length; i ++) {\r\n        os[1][i] = new Array(60);\r\n        for(let j = 0; j < os[1][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[1].length - 1 || j === os[1][i].length - 1) {\r\n                wall(i, j, 1);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第三关\r\n    os[2] = new Array(60);\r\n    for(let i = 0; i < os[2].length; i ++) {\r\n        os[2][i] = new Array(60);\r\n        for(let j = 0; j < os[2][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[2].length - 1 || j === os[2][i].length - 1) {\r\n                wall(i, j, 2);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 2);\r\n            }\r\n            else if( j > 25 && j < 35 && i === 30 ){\r\n                wall(i, j, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第四关\r\n    os[3] = new Array(60);\r\n    for(let i = 0; i < os[3].length; i ++) {\r\n        os[3][i] = new Array(60);\r\n        for(let j = 0; j < os[3][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[3].length - 1 || j === os[3][i].length - 1) {\r\n                wall(i, j, 3);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 3);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第五关\r\n    os[4] = new Array(60);\r\n    for(let i = 0; i < os[4].length; i ++) {\r\n        os[4][i] = new Array(60);\r\n        for(let j = 0; j < os[4][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[4].length - 1 || j === os[4][i].length - 1) {\r\n                wall(i, j, 4);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 4);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 4);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && i === 21){\r\n                wall(i, j, 4);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第6关\r\n    os[5] = new Array(60);\r\n    for(let i = 0; i < os[5].length; i ++) {\r\n        os[5][i] = new Array(60);\r\n        for(let j = 0; j < os[5][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[5].length - 1 || j === os[5][i].length - 1) {\r\n                wall(i, j, 5);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 5);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 5);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 5);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第7关\r\n    os[6] = new Array(60);\r\n    for(let i = 0; i < os[6].length; i ++) {\r\n        os[6][i] = new Array(60);\r\n        for(let j = 0; j < os[6][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[6].length - 1 || j === os[6][i].length - 1) {\r\n                wall(i, j, 6);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 6);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 6);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 6);\r\n            }\r\n\r\n            else if( i === 3 && (j < 8 || j > 52) && j !== 1 && j !== 58 ){\r\n                wall(i, j, 6);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 创建第八关\r\n    os[7] = new Array(60);\r\n    for(let i = 0; i < os[7].length; i ++) {\r\n        os[7][i] = new Array(60);\r\n        for(let j = 0; j < os[7][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[7].length - 1 || j === os[7][i].length - 1) {\r\n                wall(i, j, 7);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 7);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 7);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 7);\r\n            }\r\n\r\n            else if( i === 3 && ((j < 10 && j > 14) || (j < 50 && j > 46)) && j !== 1 && j !== 58 ){\r\n                wall(i, j, 7);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 创建第9关的数据\r\n    os[8] = new Array(60);\r\n    for(let i = 0; i < os[8].length; i ++) {\r\n        os[8][i] = new Array(60);\r\n        for(let j = 0; j < os[8][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[8].length - 1 || j === os[8][i].length - 1) {\r\n                wall(i, j, 8);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 8);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 8);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 8);\r\n            }\r\n\r\n            else if( i === 4 && j !== 30 && j !== 1 && j !== 58 ){\r\n                wall(i, j, 8);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 设置某个位置为墙\r\nfunction wall(i, j, num) {\r\n    os[num][i][j] = { type: \"墙\" };\r\n}\r\n\r\ncreateOs();\r\n\r\n\r\n\r\n\r\nfunction getOs(shutNum) {\r\n    return os[shutNum];\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (getOs);\n\n//# sourceURL=webpack:///./src/os.js?");

/***/ })

/******/ });