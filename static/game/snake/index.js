/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/AI.js":
/*!*******************!*\
  !*** ./src/AI.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createSnake__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createSnake */ \"./src/createSnake.js\");\n\r\n\r\n\r\n\r\n\r\nfunction AI(num) {\r\n    for(let i = 0; i < num; i ++) {\r\n        // 创建AI蛇\r\n        setTimeout(() => {\r\n            const AI = new _createSnake__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"AI蛇\");\r\n            AI.openTerval();\r\n        }, 3000 * (i + 1))\r\n    }\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AI);\n\n//# sourceURL=webpack:///./src/AI.js?");

/***/ }),

/***/ "./src/createFood.js":
/*!***************************!*\
  !*** ./src/createFood.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst app = document.querySelector(\"#snake\");\r\n\r\nlet os = null;\r\n\r\nclass Food {\r\n    constructor(osData) {\r\n        osData && (os = osData);\r\n\r\n        this.width = 10;\r\n        this.height = 10;\r\n        \r\n        // 食物的渲染\r\n        this.createDom();\r\n        \r\n        // 随机产生一个食物的位置\r\n        this.rp();\r\n    }\r\n    // 随机产生食物的位置\r\n    rp() {\r\n        const x = parseInt(Math.random() * 60);\r\n        const y = parseInt(Math.random() * 60);\r\n        // 判断食物位置有没有东西，如果有，在重新生成，没有的话，保存\r\n        if( os[y][x] || (x < 6 && y <= 1) ) this.rp();\r\n        else {\r\n            this.left = x * 10;\r\n            this.top = y * 10;\r\n            this.dom.style.left = this.left + \"px\";\r\n            this.dom.style.top = this.top + \"px\";\r\n            os[y][x] = {\r\n                type: \"食物\",\r\n                dom: this.dom,\r\n                a: true\r\n            }\r\n        }\r\n    }\r\n    // 食物的渲染\r\n    createDom() {\r\n        const dom = document.createElement(\"div\");\r\n        dom.style.width = this.width + \"px\";\r\n        dom.style.height = this.height + \"px\";\r\n        dom.style.position = \"absolute\";\r\n        dom.style.boxSizing = \"border-box\";\r\n        dom.style.border = \"1px solid #fff\";\r\n        \r\n        dom.style.background = \"#FF9800\";\r\n        \r\n        app.appendChild(dom);\r\n        this.dom = dom;\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Food);\n\n//# sourceURL=webpack:///./src/createFood.js?");

/***/ }),

/***/ "./src/createSnake.js":
/*!****************************!*\
  !*** ./src/createSnake.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createFood__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createFood */ \"./src/createFood.js\");\n\r\n\r\nconst app = document.querySelector(\"#snake\");\r\nconst menu = document.querySelector(\".menu\");\r\n\r\n// 全局背景对象\r\nlet os = null;\r\n// 保存人工蛇是否死亡的标识\r\nlet dS = false;\r\n\r\nclass Snake{\r\n    constructor(name, osData) {\r\n        // 保存全局背景对象\r\n        osData && (os = osData);\r\n\r\n        this.name = name;\r\n        this.length = 5;\r\n        this.moveLength = 5;\r\n        this.direction = \"right\";\r\n        // 影响蛇移动的速度\r\n        this.time = 250;\r\n        this.distance = 10;\r\n        this.snokeBody = [];\r\n        this.terval = null;\r\n        // AI蛇走几步，智能改变方向\r\n        this.AILingth = 0;\r\n        this.dS = false;\r\n\r\n        // 构建初始化蛇\r\n        this.createSnake();\r\n        // 表示创建的是人工蛇\r\n        if(name !== \"AI蛇\") dS = false;\r\n    }\r\n\r\n    // 构建蛇\r\n    createSnake() {\r\n        for(let i = 0; i < this.length; i ++) {\r\n            const type = i === this.length - 1 ? \"蛇头\" : \"蛇身\";\r\n            // 保存蛇身对象\r\n            this.snokeBody[i] = new SnakeBody(this.name, type, 10, 10, this.direction, this.distance, this);\r\n        }\r\n    }\r\n\r\n    // 开启蛇移动定时器的方法\r\n    openTerval() {\r\n        // 算出AI蛇的第一个智能拐点\r\n        if(this.name === \"AI蛇\") {\r\n            this.uRC(\"right\", this.length, 1);\r\n        }\r\n\r\n        this.terval = setInterval( () => {\r\n            // 判断人工蛇是否死亡，如果死亡，关闭智能蛇的定时器\r\n            if(dS) {\r\n                this.death();\r\n                return;\r\n            }\r\n            // 蛇进行移动，需要移动的方法\r\n            this.move();\r\n        }, this.time )\r\n    }\r\n    // 蛇移动的方法\r\n    move() {\r\n        this.AI && this.AI();\r\n        let boo = null;\r\n\r\n        // 初始时，滑动弹出\r\n        if(this.moveLength >= 0) {\r\n            this.moveLength --;\r\n        }\r\n        for(let i = this.snokeBody.length - 1; i >= 0; i --) {\r\n            if(i < this.moveLength) return;\r\n\r\n            // 蛇身动一下\r\n            const b = this.snokeBody[i].move();\r\n            // 蛇死亡的处理\r\n            if(b === \"死亡\") {\r\n                boo = b; \r\n            }\r\n            // 蛇吃食的处理(此时蛇尾还没有进行运动，可以在最后拼接一节)\r\n            else if(b === \"食物\") {\r\n                boo = b; \r\n            }\r\n        }\r\n        // 蛇死亡的处理\r\n        if(boo === \"死亡\") {\r\n            this.death();\r\n        }\r\n        // 蛇吃食的处理(此时蛇尾还没有进行运动，可以在最后拼接一节)\r\n        else if(boo === \"食物\") {\r\n            // 蛇的长度加一\r\n            this.length += 1;\r\n            // 吃食的处理\r\n            this.eatFood();\r\n        }\r\n    }\r\n    // 绑定事件，蛇拐弯\r\n    bEvent() {\r\n        window.onkeydown = (e) => {\r\n            // 得到新的方向\r\n            const direction = this.comDirection(e.keyCode);\r\n            // 方向发生变化，蛇拐弯，保存拐点，蛇头的位置就是拐点\r\n            this.cD(direction);\r\n        }\r\n    }\r\n    // 改变方向\r\n    cD(direction) {\r\n        if(direction !== this.direction) {\r\n            this.direction = direction;\r\n            // 取拐点\r\n            const turn = {};\r\n            turn.left = this.snokeBody[ this.snokeBody.length - 1 ].left;\r\n            turn.top = this.snokeBody[ this.snokeBody.length - 1 ].top;\r\n            turn.direction = direction;\r\n            // 设置蛇身的拐点\r\n            this.setSBTurn(turn);\r\n        }\r\n    }\r\n    // 根据按键，计算出方向\r\n    comDirection(keyCode) {\r\n        if( this.direction === \"left\" || this.direction === \"right\" ) {\r\n            if(keyCode == 38) return \"top\";\r\n            else if(keyCode == 40) return \"bottom\";\r\n        }\r\n        else if( this.direction === \"top\" || this.direction === \"bottom\" ) {\r\n            if(keyCode == 37) return \"left\";\r\n            else if(keyCode == 39) return \"right\";\r\n        }\r\n        // 还是返回之前的方向，没有改变\r\n        return this.direction;\r\n    }\r\n    // 设置蛇身的拐点\r\n    setSBTurn(turn) {\r\n        // 每个蛇身对象，都需要设置\r\n        this.snokeBody.forEach( (item, i) => {\r\n            item.turn.push(turn);\r\n        } )\r\n    }\r\n    // 蛇死亡的处理\r\n    death() {\r\n        console.log(\"蛇死亡\");\r\n        // 关掉定时器\r\n        clearInterval( this.terval );\r\n        // 标记当前蛇已经死亡\r\n        this.dS = true;\r\n\r\n        // 如果是智能蛇死亡，不清空背景，人工蛇还在运动\r\n        if(this.name !== \"AI蛇\") {\r\n            // 关掉事件函数\r\n            window.onkeydown = null;\r\n            dS = true;\r\n            menu.style.display = \"block\";\r\n            app.innerHTML = \"\";\r\n            for(let i = 0; i < os.length; i ++) {\r\n                for(let j = 0; j < os[i].length; j ++) {\r\n                    if(os[i][j] && os[i][j].type !== \"墙\") os[i][j] = null;\r\n                }\r\n            }\r\n            os = null;\r\n            alert(\"蛇死亡\");\r\n        }\r\n        // 如果是智能蛇\r\n        else {\r\n            if(dS) return;\r\n            // 智能蛇的蛇体变成实物\r\n            const food = this.snokeBody;\r\n            for(let i = 0; i < food.length; i ++) {\r\n                const x = food[i].left / 10;\r\n                const y = food[i].top / 10;\r\n                const dom = food[i].dom;\r\n                dom.style.background = \"#FF9800\";\r\n                if(!os[y][x] || os[y][x] && os[y][x].type != \"墙\" && os[y][x].type != \"食物\" && (y > 1 || x > 6)) {\r\n                    console.log(x, y);\r\n                    os[y][x] = {\r\n                        dom,\r\n                        type: \"食物\"\r\n                    }\r\n                }else {\r\n                    dom.remove();\r\n                }\r\n            }\r\n            // 在创建一条智能蛇\r\n            const AI = new Snake(\"AI蛇\");\r\n            AI.openTerval();\r\n        }\r\n    }\r\n    // 吃食的处理\r\n    eatFood() {\r\n        // 取出蛇尾的位置\r\n        let x = this.snokeBody[0].left / 10;\r\n        let y = this.snokeBody[0].top / 10;\r\n        const turn = [ ...this.snokeBody[0].turn ];\r\n        // 蛇尾移动的方向\r\n        const direction = this.snokeBody[0].direction;\r\n        if(direction == \"top\") y += 1;\r\n        else if(direction == \"bottom\") y -= 1;\r\n        else if(direction == \"left\") x += 1;\r\n        else if(direction == \"right\") x -= 1;\r\n\r\n        // 构建出一截蛇身数据\r\n        const snakeBody = new SnakeBody(this.name, \"蛇身\", x * 10, y * 10, direction, this.distance, this);\r\n        // 保存拐点信息\r\n        snakeBody.turn = turn;\r\n        this.snokeBody.unshift(snakeBody);\r\n        // 标识不用手动修改，会被蛇身直接替换掉，也可以修改\r\n    }\r\n\r\n\r\n    // 智能蛇的自动拐弯\r\n    AI() {\r\n        if(this.name !== \"AI蛇\") return;\r\n        // 此时蛇还没有移动\r\n        // 获取蛇头移动的方向\r\n        const direction = this.snokeBody[ this.snokeBody.length - 1 ].direction;\r\n        // 获取蛇头的位置\r\n        let x = this.snokeBody[ this.snokeBody.length - 1 ].left / 10;\r\n        let y = this.snokeBody[ this.snokeBody.length - 1 ].top / 10;\r\n        \r\n\r\n        // 判断AI蛇的蛇头将要前往的位置，是否有障碍物\r\n        const tD = this.AItL(direction, x, y);\r\n        // 有障碍物，紧急避障\r\n        if(tD && tD !== direction) {\r\n            // 当前已经拐了\r\n            this.cD(tD);\r\n            // 更新随机拐的位置\r\n            this.uRC(tD, x, y);\r\n            return;\r\n        }\r\n\r\n        // 食物在附近不拐弯，只有达到条件后拐弯\r\n        const cWFjtD = this.AIcWFj(direction, x, y);\r\n        if(cWFjtD && this.moveLength < 0) {\r\n            if(cWFjtD !== direction) {\r\n                this.cD(cWFjtD);\r\n                // 更新随机拐的位置\r\n                this.uRC(cWFjtD, x, y);\r\n                return;\r\n            }\r\n        }\r\n        // 食物不在附近，随机拐\r\n        else {\r\n            // 随机拐弯\r\n            const cWtD = this.AIcW(direction, x, y);\r\n            if(cWtD && cWtD !== direction) {\r\n                this.cD(cWtD);\r\n                // 更新随机拐的位置\r\n                this.uRC(cWtD, x, y);\r\n            }\r\n        }\r\n        // 判断智能蛇的蛇头前方将要前往的地方，有没有其他的蛇头，也将要前往该位置\r\n        const A = this.AIA(direction, x, y);\r\n        if(A != direction) {\r\n            this.cD(A);\r\n            // 更新随机拐的位置\r\n            this.uRC(A, x, y);\r\n        }\r\n    }\r\n    // 根据方向，返回蛇的新方向\r\n    AItL(direction, x, y) {\r\n        let _x = x;\r\n        let _y = y;\r\n        \r\n        // 得到蛇头将要前往的目标位置点，判断有没有障碍物\r\n        if(direction == \"top\") _y -= 1;\r\n        else if(direction == \"bottom\") _y += 1;\r\n        else if(direction == \"left\") _x -= 1;\r\n        else if(direction == \"right\") _x += 1;\r\n        \r\n        // 判断智能蛇将要前往的方向，是否有障碍物，即墙或者蛇身，紧急避障\r\n        if( this.AIoj(_x, _y) ) {\r\n            const nD = this.AInD(direction, x, y);\r\n            return nD;\r\n        }\r\n    }\r\n    // 判断某个位置有没有障碍物\r\n    AIoj(x, y) {\r\n        if(os[y][x] && (os[y][x].type === \"墙\" || os[y][x].type === \"蛇\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // 判断某个位置有没有墙\r\n    AIq(x, y) {\r\n        if(os[y][x] && (os[y][x].type === \"墙\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // 计算得到新的方向(往哪个方向拐，哪个方向可以拐出的方式多，哪个方向权重就大)\r\n    AInD(direction, x, y) {\r\n        // 计算新的方向\r\n        if(direction === \"top\" || direction === \"bottom\") {\r\n            // 计算两个方向的权重\r\n            const leftWeight = this.AILeftWeight(x, y);\r\n            const rightWeight = this.AIRightWeight(x, y);\r\n            if(leftWeight > 0 && leftWeight >= rightWeight) return \"left\";\r\n            else if( rightWeight > 0 && leftWeight < rightWeight ) return \"right\";\r\n        }\r\n        else if(direction === \"left\" || direction === \"right\") {\r\n            // 计算两个方向的权重\r\n            const topWeight = this.AITopWeight(x, y);\r\n            const bottomWeight = this.AIBottomWeight(x, y);\r\n            if(topWeight > 0 && topWeight >= bottomWeight) return \"top\";\r\n            else if( bottomWeight > 0 && topWeight < bottomWeight ) return \"bottom\";\r\n        }\r\n        return direction;\r\n    }\r\n    // 计算left方向的权重\r\n    AILeftWeight(x, y, type) {\r\n        let num = 0;\r\n        for(let i = x - 1; i >= 0; i --) {\r\n            if(type === \"墙\") {\r\n                if(this.AIq(i, y)) return num;\r\n            }\r\n            // 有障碍物，停止增加\r\n            else {\r\n                if(this.AIoj(i, y)) return num;\r\n            }\r\n            if( !this.AIoj(i, y + 1) || !this.AIoj(i, y - 1) ) {\r\n                num ++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n    // 计算right方向的权重\r\n    AIRightWeight(x, y, type) {\r\n        let num = 0;\r\n        for(let i = x + 1; i < os[y].length; i ++) {\r\n            if(type === \"墙\") {\r\n                if(this.AIq(i, y)) return num;\r\n            }\r\n            // 有障碍物，停止增加\r\n            else {\r\n                if(this.AIoj(i, y)) return num;\r\n            }\r\n            \r\n            if( !this.AIoj(i, y + 1) || !this.AIoj(i, y - 1) ) {\r\n                num ++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n    // 计算top方向的权重\r\n    AITopWeight(x, y, type) {\r\n        let num = 0;\r\n        for(let i = y - 1; i >= 0; i --) {\r\n            if(type === \"墙\") {\r\n                if(this.AIq(x, i)) return num;\r\n            }\r\n            // 有障碍物，停止增加\r\n            else {\r\n                if(this.AIoj(x, i)) return num;\r\n            }\r\n            if( !this.AIoj(x + 1, i) || !this.AIoj(x - 1, i) ) {\r\n                num ++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n    // 计算bottom方向的权重\r\n    AIBottomWeight(x, y, type) {\r\n        let num = 0;\r\n        for(let i = y + 1; i < os.length; i ++) {\r\n            if(type === \"墙\") {\r\n                if(this.AIq(x, i)) return num;\r\n            }\r\n            // 有障碍物，停止增加\r\n            else {\r\n                if(this.AIoj(x, i)) return num;\r\n            }\r\n            if( !this.AIoj(x + 1, i) || !this.AIoj(x - 1, i) ) {\r\n                num ++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n\r\n    // 更新随机拐的位置\r\n    uRC(direction, x, y) {\r\n        this.AILingth = parseInt(Math.random() * 4) + 4;\r\n        // 判断随机生成的位置是否正常\r\n        this[\"AI\" + direction[0].toUpperCase() + direction.substr(1) + \"Target\"](x, y);\r\n    }\r\n    // 蛇头正在往左边跑，查看生成的下次拐弯的拐点是否合适(AILingth)\r\n    AILeftTarget(x, y) {\r\n        let _length = 0;\r\n        let _i = 0;\r\n        for(let i = x - 1; i >= 0; i --) {\r\n            const num = this.AITopWeight(i, y, \"墙\") + this.AIBottomWeight(i, y, \"墙\");\r\n            if(num > 1) {\r\n                _i ++;\r\n                _length = x - i;\r\n            }\r\n            if( i === 0 && _i <= 2) {\r\n                return this.AILingth = _length;\r\n            }\r\n        }\r\n    }\r\n    // 蛇头正在往右边跑，查看生成的下次拐弯的拐点是否合适(AILingth)\r\n    AIRightTarget(x, y) {\r\n        let _length = 0;\r\n        let _i = 0;\r\n        // 拐点路径是否被墙给封死，如果封死，找最近的出口，出去，拐点应该定义在出口位置\r\n        for(let i = x + 1; i <= os[y].length - 1; i ++) {\r\n            const num = this.AITopWeight(i, y, \"墙\") + this.AIBottomWeight(i, y, \"墙\");\r\n            if(num > 1) {\r\n                _i ++;\r\n               _length = i - x;\r\n            }\r\n            if( i === os[y].length - 1 && _i <= 2 && _length !== 0) {\r\n                console.log(_length);\r\n                return this.AILingth = _length;\r\n            }\r\n        }\r\n    }\r\n    // 蛇头正在往上边跑，查看生成的下次拐弯的拐点是否合适(AILingth)\r\n    AITopTarget(x, y) {\r\n        let _length = 0;\r\n        let _i = 0;\r\n\r\n        // 拐点路径是否被墙给封死，如果封死，找最近的出口，出去，拐点应该定义在出口位置\r\n        for(let i = y - 1; i >= 0; i --) {\r\n            const num = this.AILeftWeight(x, i, \"墙\") + this.AIRightWeight(x, i, \"墙\");\r\n            if(num > 1) {\r\n                _i ++;\r\n                _length = y - i;\r\n            }\r\n            if( i == 0 && _i <= 2 && _i > 0) {\r\n                return this.AILingth = _length;\r\n            }\r\n        }\r\n    }\r\n    // 蛇头正在往下边跑，查看生成的下次拐弯的拐点是否合适(AILingth)\r\n    AIBottomTarget(x, y) {\r\n        let _length = 0;\r\n        let _i = 0;\r\n\r\n        for(let i = y + 1; i <= os.length - 1; i ++) {\r\n            \r\n            const num = this.AILeftWeight(x, i, \"墙\") + this.AIRightWeight(x, i, \"墙\");\r\n            if(num > 1) {\r\n                _i ++;\r\n                _length = i - y;\r\n            }\r\n            if(i == os.length - 1 && _i <= 2 && _i > 0) {\r\n                console.log(_length, \"bottom\");\r\n                return this.AILingth = _length;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 食物在附近，拐弯\r\n    AIcWFj(direction, x, y) {\r\n        const {_x, _y} = this.AIFj(direction, x, y);\r\n\r\n        // 判断蛇头前进的位置的两侧，有没有食物\r\n        if( direction === \"top\" && _y <= y ||\r\n            direction === \"bottom\" && _y >= y ) {\r\n            if(_x > x && _y == y) return \"right\";\r\n            else if(_x < x && _y == y) return \"left\";\r\n            return direction;\r\n        }\r\n        else if(direction === \"left\" && _x <= x ||\r\n            direction === \"right\" && _x >= x) {\r\n            if(_y > y && _x == x) return \"bottom\";\r\n            else if(_y < y && _x == x) return \"top\";\r\n            return direction;\r\n        }\r\n    }\r\n    // 得到最近食物的位置\r\n    AIFj(x, y) {\r\n        for(let i = y - 9; i <= y + 9; i ++) {\r\n            for(let j = x - 9; j <= x + 9; j ++) {\r\n                if(os[i] && os[i][j] && os[i][j].type === \"食物\") {\r\n                    return {\r\n                        _y: i,\r\n                        _x: j\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {}\r\n    }\r\n    snakePan(x, y) {\r\n        for(let i = y - 2; i <= y + 2; i ++) {\r\n            for(let j = x - 2; j <= x + 2; j ++) {\r\n                if(os[i] && os[i][j] && os[i][j].type === \"蛇\") return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    // 随机改变位置\r\n    AIcW(direction, x, y) {\r\n        // 蛇头已经弹出，拐点的步数才开始递减\r\n        if( this.moveLength > 0 ) return;\r\n        this.AILingth --;\r\n        // 判断是否到达智能改变方向的地步\r\n        if(this.AILingth > 0) return;\r\n        // 如果到达拐点，还是无法拐动，该方法返回的是原方向，继续走\r\n        // this.AILingth并没有重新赋值(方向没有变化)\r\n        // 下次还会触发该函数(上面拦截不了)，继续判断是否可以拐\r\n\r\n        const nD = this.AInD(direction, x, y);\r\n        // const nD = this.minFood(direction, x, y);\r\n        return nD;\r\n    }\r\n    // 遍历整个背景，找到最近的食物的方向进行拐弯\r\n    minFood(direction, x, y) {\r\n        let length = 1000;\r\n        let _x = 0;\r\n        let _y = 0;\r\n        for(let i = 0; i < os.length; i ++) {\r\n            for(let j = 0; j < os[i].length; j ++) {\r\n                if(os[i][j] && os[i][j].type == \"食物\" && Math.abs(j - x) + Math.abs(i - y) < length) {\r\n                    length = Math.abs(j - x) + Math.abs(i - y);\r\n                    _x = j;\r\n                    _y = i;\r\n                }\r\n            }\r\n        }\r\n        if(direction == \"top\" || direction == \"bottom\") {\r\n            if(_x > x) return \"right\";\r\n            else if(_x < x) return \"left\";\r\n        }\r\n        else if(direction == \"left\" || direction == \"right\") {\r\n            if(_y > y) return \"bottom\";\r\n            else if(_y < y) return \"top\";\r\n        }\r\n        return direction;\r\n    }\r\n    AIA (direction, x, y) {\r\n        if(direction === \"top\") y -= 1;\r\n        else if(direction === \"bottom\") y += 1;\r\n        else if(direction === \"left\") x -= 1;\r\n        else if(direction === \"right\") x += 1;\r\n\r\n        for(let i = y - 1; i < y + 1; i ++) {\r\n            for(let j = x - 1; j < x + 1; j ++) {\r\n                if( os[i][j] && os[i][j].t === \"蛇头\" && i != y && j != x )  {\r\n                    return this.AInD(direction, x, y);\r\n                }\r\n            }\r\n        }\r\n        return direction;\r\n    }\r\n}\r\n\r\n\r\n\r\nclass SnakeBody {\r\n    constructor(name, type, left, top, direction, distance, root) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.width = 10;\r\n        this.height = 10;\r\n        this.left = left;\r\n        this.top = top;\r\n        this.direction = direction;\r\n        this.distance = distance;\r\n        this.dom = null;\r\n        this.turn = [];\r\n        this.root = root;\r\n\r\n        this.createDom();\r\n    }\r\n    createDom() {\r\n        const dom = document.createElement(\"div\");\r\n        dom.style.width = this.width + \"px\";\r\n        dom.style.height = this.height + \"px\";\r\n        dom.style.position = \"absolute\";\r\n        dom.style.boxSizing = \"border-box\";\r\n        dom.style.border = \"1px solid #fff\";\r\n        // 在背景中添加蛇身的标识\r\n        this.addObstacle();\r\n\r\n        if(this.type === \"蛇头\") {\r\n            dom.style.background = \"#E91E63\";\r\n        }\r\n        else {\r\n            if(this.name === \"AI蛇\") dom.style.background = \"#673AB7\";\r\n            else dom.style.background = \"#9c27b0\";\r\n        }\r\n        app.appendChild(dom);\r\n        this.dom = dom;\r\n\r\n        // 渲染蛇身的位置\r\n        this.rl();\r\n    }\r\n    // 在背景中添加蛇身标识，表明此处为障碍物\r\n    addObstacle() {\r\n        // 确定位置\r\n        const x = this.left / 10;\r\n        const y = this.top / 10;\r\n        if( os[y][x] && os[y][x].type === \"墙\") return;\r\n        os[y][x] = {\r\n            type: \"蛇\",\r\n            name: this.name,\r\n            t: this.type\r\n        }\r\n    }\r\n    // 在背景中移除当前蛇身的处理，障碍物移除\r\n    clearObstacle() {\r\n        // 确定位置\r\n        const x = this.left / 10;\r\n        const y = this.top / 10;\r\n        if( os[y][x] && os[y][x].type === \"墙\") return;\r\n        os[y][x] = null;\r\n    }\r\n    // 根据蛇身位置，渲染蛇身\r\n    rl() {\r\n        this.dom.style.left = this.left + \"px\";\r\n        this.dom.style.top = this.top + \"px\";\r\n    }\r\n    // 蛇身移动\r\n    move() {\r\n        if(!os || this.root.dS) return;\r\n\r\n        // 在背景中移除当前蛇身的处理，障碍物移除，蛇将要前往下一个位置\r\n        this.clearObstacle();\r\n\r\n        // 查看当前位置是否为拐点，如果是，改变方向\r\n        this.changeDirection();\r\n        // 根据方向，更新下次前往的坐标\r\n        this[this.direction + \"Move\"]();\r\n        \r\n        // 进行蛇头前方障碍物的判断\r\n        if( this.oj() ) return \"死亡\";\r\n\r\n        // 根据蛇身数据，渲染蛇身的位置\r\n        this.rl();\r\n\r\n        // 判断蛇头前方是否为食物(吃食，蛇头要正常移动，所以放在移动渲染的后面退出函数)\r\n        if( this.fj() ) return \"食物\";\r\n\r\n        // 在背景中添加蛇身的标识，蛇身的新位置\r\n        this.addObstacle();\r\n        \r\n        return false;\r\n    }\r\n    // 移动方向的改变\r\n    changeDirection() {\r\n        // 存在拐点，判断是否到达拐点\r\n        if( this.turn.length > 0 ) {\r\n            for(let i = 0; i < this.turn.length; i ++) {\r\n                if(this.left === this.turn[i].left && this.top === this.turn[i].top) {\r\n                    // 拐弯\r\n                    this.direction = this.turn[i].direction;\r\n                    // 清除拐点\r\n                    this.turn.splice(i, 1);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 蛇身左移函数\r\n    leftMove() {\r\n        this.left -= this.distance;\r\n    }\r\n    // 蛇身右移函数\r\n    rightMove() {\r\n        this.left += this.distance;\r\n    }\r\n    // 蛇身上移函数\r\n    topMove() {\r\n        this.top -= this.distance;\r\n    }\r\n    // 蛇身下移函数\r\n    bottomMove() {\r\n        this.top += this.distance;\r\n    }\r\n\r\n    // 进行蛇头前方障碍物的判断\r\n    oj() {\r\n        if(this.type === \"蛇头\") {\r\n            // 判断当前蛇头位置，是否碰到了障碍物\r\n            // 确定位置\r\n            const x = this.left / 10;\r\n            const y = this.top / 10;\r\n            if(os[y][x] && (os[y][x].type === \"蛇\" || os[y][x].type === \"墙\")) {\r\n                this.root.dS = true;\r\n                if( this.direction == \"left\") this.left += 10;\r\n                else if( this.direction == \"right\") this.left -= 10;\r\n                else if( this.direction == \"bottom\") this.top -= 10;\r\n                else if( this.direction == \"top\") this.top += 10;\r\n                this.rl();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // 进行蛇头前方食物的判断\r\n    fj() {\r\n        if(this.type === \"蛇头\") {\r\n            // 判断当前蛇头位置，是否碰到了障碍物\r\n            // 确定位置\r\n            const x = this.left / 10;\r\n            const y = this.top / 10;\r\n            if(os[y][x] && os[y][x].type === \"食物\") {\r\n                os[y][x].dom.remove();\r\n                // 创建新的食物，吃的是系统生成的食物，而不是AI蛇死亡的食物\r\n                if(os[y][x].a) new _createFood__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Snake);\n\n//# sourceURL=webpack:///./src/createSnake.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\r\n\r\n\r\nconst menu = document.querySelector(\".menu\");\r\nconst sPPlus = document.querySelector(\".sPPlus\");\r\nconst sPNumDom = document.querySelector(\".sPNum\");\r\nconst sPReduce = document.querySelector(\".sPReduce\");\r\n\r\n\r\nconst enable = document.querySelector(\".enable\");\r\nconst AINumG = document.querySelector(\".AINumG\");\r\nconst AIPlus = document.querySelector(\".AIPlus\");\r\nconst AINumDom = document.querySelector(\".AINum\");\r\nconst AIReduce = document.querySelector(\".AIReduce\");\r\nconst start = document.querySelector(\".start\");\r\n\r\n\r\n\r\nsPPlus.onclick = () => {\r\n    if(sPNumDom.innerHTML < 9) sPNumDom.innerHTML = +sPNumDom.innerHTML + 1;\r\n}\r\nsPReduce.onclick = () => {\r\n    if(sPNumDom.innerHTML > 1) sPNumDom.innerHTML -= 1;\r\n}\r\n\r\n\r\nlet AIB = false;\r\n\r\nenable.onclick = () => {\r\n    AIB = !AIB;\r\n    if(AIB) {\r\n        AINumG.style.display = \"block\";\r\n        enable.innerHTML = \"关闭智能蛇\";\r\n    }\r\n    else {\r\n        AINumG.style.display = \"none\";\r\n        enable.innerHTML = \"启用智能蛇\";\r\n    }\r\n}\r\nAIPlus.onclick = () => {\r\n    if(AINumDom.innerHTML < 3) AINumDom.innerHTML = +AINumDom.innerHTML + 1;\r\n}\r\nAIReduce.onclick = () => {\r\n    if(AINumDom.innerHTML > 1) AINumDom.innerHTML -= 1;\r\n}\r\n\r\nstart.onclick = () => {\r\n    // 获取关数\r\n    const sPNum = +sPNumDom.innerHTML;\r\n    // 获取智能蛇开启的数量\r\n    const AINum = +AINumDom.innerHTML;\r\n    menu.style.display = \"none\";\r\n    \r\n    Object(_main_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(sPNum, AINum, AIB);\r\n}\r\n\r\n\r\n\r\n\r\n// main(1);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./os */ \"./src/os.js\");\n/* harmony import */ var _createSnake__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createSnake */ \"./src/createSnake.js\");\n/* harmony import */ var _createFood__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createFood */ \"./src/createFood.js\");\n/* harmony import */ var _AI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AI */ \"./src/AI.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 获取全局背景对象\r\nlet os = null;\r\n\r\nfunction main(shutNum, AInum, AIB) {\r\n    os = Object(_os__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(shutNum - 1);\r\n    // 渲染全局障碍物\r\n    rWall(os);\r\n    // 渲染初始化蛇\r\n    const snake = new _createSnake__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"人工蛇\", os);\r\n    // 构建初始化食物\r\n    createNumFood()\r\n    // 蛇移动\r\n    snake.openTerval();\r\n    // 绑定事件，蛇拐弯\r\n    snake.bEvent();\r\n\r\n    // 启动AI\r\n    AIB && Object(_AI__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(AInum);\r\n}\r\n\r\n// 构建一定数量的食物\r\nfunction createNumFood() {\r\n    for(let i = 0; i < 8; i ++) {\r\n        // 构建初始食物\r\n        new _createFood__WEBPACK_IMPORTED_MODULE_2__[\"default\"](os);\r\n    }\r\n}\r\n\r\n\r\n\r\nconst app = document.querySelector(\"#snake\");\r\n\r\nfunction rWall(os) {\r\n    os.forEach( (item, i) => {\r\n        item.forEach( (key, j) => {\r\n            if(key && key.type === \"墙\") {\r\n                const dom = document.createElement(\"div\");\r\n                dom.style.width = \"10px\";\r\n                dom.style.height = \"10px\";\r\n                dom.style.left = j * 10 + \"px\";\r\n                dom.style.top = i * 10 + \"px\";\r\n                dom.style.position = \"absolute\";\r\n                dom.style.background = \"#799456\";\r\n                dom.style.boxSizing = \"border-box\";\r\n                dom.style.border = \"1px solid #fff\";\r\n                \r\n                app.appendChild(dom);\r\n            }\r\n        } )\r\n    } )\r\n}\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/os.js":
/*!*******************!*\
  !*** ./src/os.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\nconst os = [];\r\n\r\n\r\nfunction createOs() {\r\n    // 创建第一关的数据\r\n    os[0] = new Array(60);\r\n    for(let i = 0; i < os[0].length; i ++) {\r\n        os[0][i] = new Array(60);\r\n        for(let j = 0; j < os[0][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[0].length - 1 || j === os[0][i].length - 1) {\r\n                wall(i, j, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第二关\r\n    os[1] = new Array(60);\r\n    for(let i = 0; i < os[1].length; i ++) {\r\n        os[1][i] = new Array(60);\r\n        for(let j = 0; j < os[1][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[1].length - 1 || j === os[1][i].length - 1) {\r\n                wall(i, j, 1);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第三关\r\n    os[2] = new Array(60);\r\n    for(let i = 0; i < os[2].length; i ++) {\r\n        os[2][i] = new Array(60);\r\n        for(let j = 0; j < os[2][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[2].length - 1 || j === os[2][i].length - 1) {\r\n                wall(i, j, 2);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 2);\r\n            }\r\n            else if( j > 25 && j < 35 && i === 30 ){\r\n                wall(i, j, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第四关\r\n    os[3] = new Array(60);\r\n    for(let i = 0; i < os[3].length; i ++) {\r\n        os[3][i] = new Array(60);\r\n        for(let j = 0; j < os[3][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[3].length - 1 || j === os[3][i].length - 1) {\r\n                wall(i, j, 3);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 3);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第五关\r\n    os[4] = new Array(60);\r\n    for(let i = 0; i < os[4].length; i ++) {\r\n        os[4][i] = new Array(60);\r\n        for(let j = 0; j < os[4][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[4].length - 1 || j === os[4][i].length - 1) {\r\n                wall(i, j, 4);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 4);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 4);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && i === 21){\r\n                wall(i, j, 4);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第6关\r\n    os[5] = new Array(60);\r\n    for(let i = 0; i < os[5].length; i ++) {\r\n        os[5][i] = new Array(60);\r\n        for(let j = 0; j < os[5][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[5].length - 1 || j === os[5][i].length - 1) {\r\n                wall(i, j, 5);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 5);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 5);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 5);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建第7关\r\n    os[6] = new Array(60);\r\n    for(let i = 0; i < os[6].length; i ++) {\r\n        os[6][i] = new Array(60);\r\n        for(let j = 0; j < os[6][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[6].length - 1 || j === os[6][i].length - 1) {\r\n                wall(i, j, 6);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 6);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 6);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 6);\r\n            }\r\n\r\n            else if( i === 3 && (j < 8 || j > 52) ){\r\n                wall(i, j, 6);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 创建第八关\r\n    os[7] = new Array(60);\r\n    for(let i = 0; i < os[7].length; i ++) {\r\n        os[7][i] = new Array(60);\r\n        for(let j = 0; j < os[7][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[7].length - 1 || j === os[7][i].length - 1) {\r\n                wall(i, j, 7);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 7);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 7);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 7);\r\n            }\r\n\r\n            else if( i === 3 && (j < 10 || j > 14 && j < 50 || j > 46) ){\r\n                wall(i, j, 7);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 创建第9关的数据\r\n    os[8] = new Array(60);\r\n    for(let i = 0; i < os[8].length; i ++) {\r\n        os[8][i] = new Array(60);\r\n        for(let j = 0; j < os[8][i].length; j ++) {\r\n            if(i === 0 || j === 0 || i === os[8].length - 1 || j === os[8][i].length - 1) {\r\n                wall(i, j, 8);\r\n            }\r\n            else if( (j === 20 || j === 40) && i > 8 && i < 52 ){\r\n                wall(i, j, 8);\r\n            }\r\n            else if( j > 25 && j < 35 && (i === 30 || i === 12 || i === 48) ){\r\n                wall(i, j, 8);\r\n            }\r\n            else if( (j > 5 && j < 15 || j > 45 && j < 55) && (i === 21 || i===39) ){\r\n                wall(i, j, 8);\r\n            }\r\n\r\n            else if( i === 3 && j !== 30 ){\r\n                wall(i, j, 8);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// 设置某个位置为墙\r\nfunction wall(i, j, num) {\r\n    os[num][i][j] = { type: \"墙\" };\r\n}\r\n\r\ncreateOs();\r\n\r\n\r\n\r\n\r\nfunction getOs(shutNum) {\r\n    return os[shutNum];\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (getOs);\n\n//# sourceURL=webpack:///./src/os.js?");

/***/ })

/******/ });